from scipy.integrate import odeint
import numpy as np
import matplotlib.pyplot as plt
import math
import random

# State constraints and limitations on inputs
delta_min = -30*np.pi/180 # Minimum steering angle [rad]
delta_max = 30*np.pi/180 # Maximum steering angle [rad]
delta_dot_min = -0.4 # Minimum steering angular velocity [rad/s]
delta_dot_max = 0.4 # Maximum steering angular velocity [rad/s]

v_min = 0 # Minimum longitudinal velocity [m/s]
v_max = 15/3.6 # Maximum longitudinal velocity [m/s]
a_max = 10 # Maximum longitudinal acceleration [m/s^2]

'''
    The implementation of the kinematic bicycle model in the RRT path planning algorithm:
    
    State represented by Xn = [x, y, theta, v, delta], where: 
        x, y are the coordinates located at the center of the rear axle [m]
        theta is orientation of the car [rad]
        v is the longitudinal speed [m/s]
        delta is the steer angle [rad]
        
    Inputs: Xn - current state; a list
            u - input specified as [v_delta, a]
    Output: Xn_dot - derivative of Xn specified as [x_dot, y_dot, theta_dot, a, delta_dot]
'''

#def car_model(Xn, u):
def car_model(Xn, t, u): # Use this for simulation
    # Unpack state variables
    x, y, theta, v, delta = Xn
    x = float(x)
    y = float(y)
    theta = float(theta)
    delta = float(delta)
    v = float(v)

    # Unpack input variables
    v_delta, a = u

    L = 0.5 # wheelbase [m]

    # Implement the state constraints on the steering angle and longitudinal speed
    if delta > delta_max:
        delta = delta_max
    elif delta < delta_min:
        delta = delta_min

    if v > v_max:
        v = v_max
    elif v < v_min:
        v = v_min

    # Equations of motion
    x_dot = v * np.cos(theta)
    y_dot = v * np.sin(theta)
    delta_dot = v_delta
    v_dot = a
    theta_dot = (v / L) * np.tan(delta)

    # Derivative of state Xn
    Xn_dot = np.array([x_dot, y_dot, theta_dot, v_dot, delta_dot])

    return Xn_dot

'''
    random_config: this function generates a random point on the free configuration space Cfree
    Inputs: height - height of the screen
            width - width of the screen
    Output: a random configuration on the free configuration space Cfree
'''

def random_config(height, width):
    # Create random configuration of the mobile robot
    x = random.random() * width
    y = random.random() * height
    theta = random.random() * 2 * np.pi

    return (x, y, theta, 0, 0)

'''
    new_state: This function uses Fourth-Order Runge-Kutta (RK4) method for calculating an approximation of the next state Xn+1
    Inputs: Xn - current state; a list
            u - input of the model 
    Output: Xnew - the next state Xn+1 with respect to the current state Xn
'''

def new_state(Xn, u):
    # RK4 method
    k1 = car_model(Xn, u)
    k2 = car_model(Xn + k1 / 2, u)
    k3 = car_model(Xn + k2 / 2, u)
    k4 = car_model(Xn + k3, u)

    delta_t = 0.2 # Step size

    Xnew = Xn + (1/6) * (k1 + 2 * k2 + 2 * k3 + k4) * delta_t
    Xnew = [float(Xnew[0]), float(Xnew[1]), float(Xnew[2]), float(Xnew[3]), float(Xnew[4])]
    return Xnew

'''
    select_input: This function is calculate the next state for the vehicle dynamics. 
    It tries out the delta_f from min_steer angle to max_steer angle to 
    get the best state available via newState() function. 
    Inputs: Xrand - the random state generated by randomConfig
            Xnear - the nearest state in RRT search tree to Xrand
    Output: the best next state available 
'''

def select_input(Xrand, Xnear, obs):

    # Start with minimal input
    delta_dot = delta_dot_min
    a = 0

    bestState = None
    bestDistance = np.inf

    # Try inputs as long as delta_dot and a are below there maximum value
    while delta_dot < delta_dot_max:
        while a < a_max:
            u = [delta_dot, a] # input
            Xnew = new_state(Xnear, u) # calculate new state

            distance = np.linalg.norm(Xnew, Xrand)  # calculate Euclidean distance between two given states

            if distance < bestDistance: # Find best path that takes into account the constraints of the non-holonomic mobile robot
                bestState = Xnew
                bestDistance = distance

            a += 2 # increment a per iteration to find best input

        delta_dot += 0.05  # increment delta_dot per iteration to find best input

    return bestState

'''
    try_input: This function tries out all possible inputs at a given node Xn to 
    calculate all possible outputs
    Inputs: Xn - the state x, y, theta, v and delta of the Xn node
    Output: all - all possible outcomes of Xn with all possible inputs u
'''


def try_input(Xn):

    # Start with minimal input
    delta_dot = delta_dot_min
    a = 0

    all = []

    # Try inputs as long as delta_dot and a are below there maximum value
    while delta_dot < delta_dot_max:
        while a < a_max:
            u = [delta_dot, a] # input
            Xnew = new_state(Xn, u) # calculate new state to try

            all.append(Xnew) # add new state to list of all possible states

            a += 2 # increment a per iteration to find best input

        delta_dot += 0.05  # increment delta_dot per iteration to find best input

    return all

if __name__ == "__main__":
    initial = [4.0, 5.0, 1, 0, 0]
    u = [2, 4]
    time_step = 1000
    t = np.linspace(0, 10, time_step)

    sol = odeint(car_model, initial, t, args=(u,)) # solve a differential equation

    plt.plot(t, sol[:, 0], 'b', label='x')
    plt.plot(t, sol[:, 1], 'g', label='y')
    plt.plot(t, sol[:, 2], 'r', label='theta')
    plt.plot(t, sol[:, 3], 'y', label='v')
    plt.plot(t, sol[:, 4], 'k', label='delta')

    plt.legend(loc='best')
    plt.xlabel('t')
    plt.grid()
    plt.show()