from scipy.integrate import odeint
import numpy as np
import matplotlib.pyplot as plt
import math
import random

# State constraints and limitations on inputs
delta_min = -30*np.pi/180 # Minimum steering angle [rad]
delta_max = 30*np.pi/180 # Maximum steering angle [rad]
delta_dot_min = -0.4 # Minimum steering angular velocity [rad/s]
delta_dot_max = 0.4 # Maximum steering angular velocity [rad/s]

v_min = 0 # Minimum longitudinal velocity [m/s]
v_max = 15/3.6 # Maximum longitudinal velocity [m/s]
a_max = 10 # Maximum longitudinal acceleration [m/s^2]

'''
    The implementation of the kinematic bicycle model in the RRT path planning algorithm:
    
    State represented by Xn = [x, y, theta, v, delta], where: 
        x, y are the coordinates located at the center of the rear axle [m]
        theta is orientation of the car [rad]
        v is the longitudinal speed [m/s]
        delta is the steer angle [rad]
        
    Inputs: Xn - current state; a list
            u - input specified as [v_delta, a]
    Output: Xn_dot - derivative of Xn specified as [x_dot, y_dot, theta_dot, a, delta_dot]
'''

def car_model(Xn, u, t):
    # Unpack state variables
    x, y, theta, v, delta = Xn
    x = float(x)
    y = float(y)
    theta = float(theta)
    delta = float(delta)
    v = float(v)

    # Unpack input variables
    v_delta, a = u

    L = 0.5 # wheelbase [m]

    # Implement the state constraints on the steering angle and longitudinal speed
    if delta > delta_max:
        delta = delta_max
    elif delta < delta_min:
        delta = delta_min

    if v > v_max:
        v = v_max
    elif v < v_min:
        v = v_min

    # Equations of motion
    x_dot = v * np.cos(theta)
    y_dot = v * np.sin(theta)
    delta_dot = v_delta
    v_dot = a
    theta_dot = (v / L) * np.tan(delta)

    # Derivative of state Xn
    Xn_dot = np.array([x_dot, y_dot, theta_dot, v_dot, delta_dot])

    return Xn_dot

'''
    random_config: this function generates a random point on the free configuration space Cfree
    Inputs: height - height of the screen
            width - width of the screen
    Output: a random configuration on the free configuration space Cfree
'''

def random_config(height, width):
    # Create random configuration of the mobile robot
    x = random.random() * width
    y = random.random() * height
    theta = random.random() * 2 * np.pi

    return (x, y, theta, 0, 0)

'''
    new_state: This function uses Fourth-Order Runge-Kutta (RK4) method for calculating an approximation of the next state Xn+1
    Inputs: Xn - current state; a list
            u - input of the model 
    Output: Xnew - the next state Xn+1 with respect to the current state Xn
'''

def new_state(Xn, u):
    # RK4 method
    k1 = car_model(Xn, u)
    k2 = car_model(Xn + k1 / 2, u)
    k3 = car_model(Xn + k2 / 2, u)
    k4 = car_model(Xn + k3, u)

    delta_t = 0.2 # Step size

    Xnew = Xn + (1/6) * (k1 + 2 * k2 + 2 * k3 + k4) * delta_t
    Xnew = [float(Xnew[0]), float(Xnew[1]), float(Xnew[2]), float(Xnew[3]), float(Xnew[4])]
    return Xnew


'''
    select_input: This function is calculate the next state for the vehicle dynamics. 
    It tries out the delta_f from min_steer angle to max_steer angle to 
    get the best state available via newState() function. 
    Inputs: Xrand - the random state generated by randomConfig
            Xnear - the nearest state in RRT search tree to Xrand
    Output: the best next state available 
'''


def select_input(Xrand, Xnear, obs):
    delta_dot = delta_dot_min

    bestState = None
    bestDistance = np.inf

    while delta_dot < delta_dot_max:
        a = 0
        while a < a_max:
            u = [delta_dot, a] # input
            Xnew = new_state(Xnear, u) # calculate new state

            distance = np.linalg.norm(Xnew, Xrand)  # calculate Euclidean distance between two given states

            if distance < bestDistance: #
                bestState = Xnew
                bestDistance = distance

            a += 2 # increment a per iteration to find best input

        delta_dot += 0.05  # increment delta_dot per iteration to find best input

    return bestState


'''
    dist: This function returns the Euclidean distance between two given states
'''

'''
def dist(s1, s2):
    x1 = s1[0]
    y1 = s1[1]

    x2 = s2[0]
    y2 = s2[1]
    return np.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2))
'''

'''
    This function tries out all possible inputs at a given node Xn to 
    calculate all possible outputs
    Inputs: Xn - the state xg, yg, theta, vy, r of the Xn node
    Output: ret - all possible outcomes of Xn with all possible inputs u
'''


def try_input(Xn):
    delta_dot = delta_dot_min
    a = 0

    all = []

    while delta_dot < delta_dot_max:
        while a < a_max:
            u = [delta_dot, a] # input
            Xnew = new_state(Xn, u) # calculate new state

            all.append(Xnew) # add new state to list of all possible states

            a += 2 # increment a per iteration to find best input

        delta_dot += 0.05  # increment delta_dot per iteration to find best input

    return all


'''
    This simulator is for test only 
    NOTE: need to add 't' argument in the above Car_Dynamic function to perform test
'''


def TC_Simulate(Mode, initial, time_bound):
    time_step = 0.05
    time_bound = float(time_bound)
    initial = [float(tmp) for tmp in initial]
    number_points = int(np.ceil(time_bound / time_step))
    t = [i * time_step for i in range(0, number_points)]
    if t[-1] != time_step:
        t.append(time_bound)

    newt = []
    for step in t:
        newt.append(float(format(step, '.2f')))
    t = newt
    u = [1.0, 0]
    sol = odeint(car_model, initial, t, args=(u,), hmax=time_step)

    # Construct the final output
    trace = []
    for j in range(len(t)):
        tmp = []
        tmp.append(t[j])
        tmp.append(float(sol[j, 0]))
        tmp.append(float(sol[j, 1]))
        tmp.append(float(sol[j, 2]))
        tmp.append(float(sol[j, 3]))
        tmp.append(float(sol[j, 4]))
        trace.append(tmp)
    return trace


if __name__ == "__main__":
    sol = TC_Simulate('Default', [5.0, 5.0, 1, 0, 0], 20)
    for s in sol:
        print
        s
    a = [row[1] for row in sol]
    b = [row[2] for row in sol]

    plt.plot(a, b, '-r')
    plt.show()